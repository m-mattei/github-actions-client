name: Release on merged PR to main

on:
  workflow_run:
    workflows:
      - "Java CI"
    types:
      - completed

permissions:
  contents: write
  packages: write

jobs:
  release:
    # only run when the triggering Java CI workflow run concluded successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          distribution: temurin
          java-version: '17'

      - name: Cache Maven local repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-m2-

      - id: identify_pr_and_artifact
        name: Ensure this run corresponds to a merged PR into main and return artifact
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const run = context.payload.workflow_run;
            const runId = run.id;
            const headSha = run.head_sha;
            core.info(`Triggered by Java CI run id=${runId} head_sha=${headSha}`);

            // Find PRs associated with this commit
            const prsResp = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: headSha });
            const prs = prsResp.data || [];
            core.info(`Found ${prs.length} PR(s) associated with commit ${headSha}`);

            // Look for a PR that targets main and is merged
            let mergedPr = null;
            for (const p of prs) {
              const prDetails = await github.rest.pulls.get({ owner, repo, pull_number: p.number });
              if (prDetails.data.base && prDetails.data.base.ref === 'main' && prDetails.data.merged === true) {
                mergedPr = prDetails.data;
                break;
              }
            }

            if (!mergedPr) {
              core.info('No merged PR into main associated with this run; skipping release.');
              return { skip: 'true' };
            }

            core.info(`Found merged PR #${mergedPr.number} into main (merged_at=${mergedPr.merged_at})`);

            // Get artifacts for the triggering run
            const arts = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id: runId });
            if (!arts || !arts.data || !arts.data.artifacts || arts.data.artifacts.length === 0) {
              throw new Error(`No artifacts found for Java CI run ${runId}`);
            }
            const artifact = arts.data.artifacts.find(a => a.name === 'build-artifacts') || arts.data.artifacts[0];
            core.info(`Selected artifact ${artifact.name} (id=${artifact.id}) from run ${runId}`);
            // return PR head ref and head SHA so we can create a branch-based tag
            const pr_head_ref = mergedPr.head.ref;
            const pr_head_sha = mergedPr.head.sha;
            return { archive_url: artifact.archive_download_url, run_id: runId, pr_number: mergedPr.number, pr_user_login: mergedPr.user.login, pr_head_ref, pr_head_sha };

      - name: Set release tag and commit for branch
        id: set_release_tag
        run: |
          set -euo pipefail
          ARCHIVE_JSON="${{ steps.identify_pr_and_artifact.outputs.result }}"
          skip=$(echo "$ARCHIVE_JSON" | jq -r '.skip // empty') || true
          if [ "$skip" = "true" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          pr_head_ref=$(echo "$ARCHIVE_JSON" | jq -r '.pr_head_ref')
          pr_head_sha=$(echo "$ARCHIVE_JSON" | jq -r '.pr_head_sha')
          sanitized=${pr_head_ref//\//-}
          tag="branch-${sanitized}"
          echo "release_tag=${tag}" >> "$GITHUB_OUTPUT"
          echo "release_commit=${pr_head_sha}" >> "$GITHUB_OUTPUT"

      - name: Extract branch metadata and project version
        id: extract_metadata
        run: |
          set -euo pipefail
          ARCHIVE_JSON="${{ steps.identify_pr_and_artifact.outputs.result }}"
          echo "$ARCHIVE_JSON" > /tmp/art.json
          pr_head_ref=$(jq -r '.pr_head_ref' /tmp/art.json)
          # parse branch name like: "fix - 123 - description" or "fix-123-description"
          IFS='-' read -r p1 p2 _ <<< "$pr_head_ref"
          branch_type=$(echo "$p1" | tr '[:upper:]' '[:lower:]' | sed 's/ //g')
          story_id=$(echo "$p2" | sed 's/[^A-Za-z0-9]//g')
          # get project version via mvn (maven should be available); fallback to parsing pom.xml
          project_version=$(mvn -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec || true)
          if [ -z "$project_version" ]; then
            project_version=$(grep -m1 -oP '(?<=<version>)[^<]+' pom.xml || echo "unknown")
          fi
          echo "branch_type=${branch_type}" >> "$GITHUB_OUTPUT"
          echo "story_id=${story_id}" >> "$GITHUB_OUTPUT"
          echo "project_version=${project_version}" >> "$GITHUB_OUTPUT"

      - name: Create/force-update git tag for branch
        if: ${{ steps.set_release_tag.outputs.skip != 'true' }}
        run: |
          set -euo pipefail
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          tag="${{ steps.set_release_tag.outputs.release_tag }}"
          commit="${{ steps.set_release_tag.outputs.release_commit }}"
          # create/update tag locally and force-push to origin
          git tag -f "$tag" "$commit"
          git push -f origin "refs/tags/$tag"
        env:
          GITHUB_ACTOR: ${{ github.actor }}

      - name: Download and extract Java CI artifact
        run: |
          set -euo pipefail
          ARCHIVE_JSON="${{ steps.identify_pr_and_artifact.outputs.result }}"
          skip=$(echo "$ARCHIVE_JSON" | jq -r '.skip // empty') || true
          if [ "$skip" = "true" ]; then
            echo "No merged PR into main associated with this run; skipping release.";
            exit 0
          fi
          echo "$ARCHIVE_JSON" > /tmp/art.json
          archive_url=$(jq -r '.archive_url' /tmp/art.json)
          if [ -z "$archive_url" ] || [ "$archive_url" = "null" ]; then
            echo "No archive_url found in previous step output" >&2
            cat /tmp/art.json >&2 || true
            exit 1
          fi
          mkdir -p downloaded-artifacts
          echo "Downloading artifact from: $archive_url"
          curl -L -H "Authorization: Bearer $GITHUB_TOKEN" -o /tmp/artifact.zip "$archive_url"
          unzip -o /tmp/artifact.zip -d downloaded-artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # NOTE: We intentionally use the branch-based tag created earlier (release_tag) as the single-release identifier.
      # The tag has already been created/force-updated and any existing release for that tag deleted above.

      - name: Configure Maven settings for GitHub Packages
        run: |
          mkdir -p $HOME/.m2
          cat > $HOME/.m2/settings.xml <<'SETTINGS'
          <settings>
            <servers>
              <server>
                <id>github</id>
                <username>${env.GITHUB_ACTOR}</username>
                <password>${env.GITHUB_TOKEN}</password>
              </server>
            </servers>
          </settings>
          SETTINGS
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish JAR(s) to GitHub Packages (Maven) using deploy-file
        run: |
          set -euo pipefail
          repo_url="https://maven.pkg.github.com/m-mattei/github-actions-client"
          for jar in downloaded-artifacts/target/*.jar; do
            echo "Publishing $jar to $repo_url"
            mvn -B org.apache.maven.plugins:maven-deploy-plugin:3.0.0:deploy-file \
              -Dfile="$jar" \
              -DpomFile=pom.xml \
              -DrepositoryId=github \
              -Durl="$repo_url"
          done

      - name: Create official release
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = process.env.RELEASE_TAG;
            const identify = JSON.parse(process.env.IDENTIFY_RESULT || '{}');
            const pr_number = identify.pr_number;
            const pr_user = identify.pr_user_login || '';
            const pr_head_ref = identify.pr_head_ref || '';
            const body = `Official release created from merged PR #${pr_number} by ${pr_user}.
Branch-based single release for branch ${pr_head_ref} (this release will overwrite previous release for the branch).`;
            const branch_type = process.env.BRANCH_TYPE || '';
            const story_id = process.env.STORY_ID || '';
            const project_version = process.env.PROJECT_VERSION || '';

            // Get or create release by tag
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              core.info(`Found existing release id=${release.data.id} for tag=${tag}`);
              // update release metadata
              await github.rest.repos.updateRelease({ owner, repo, release_id: release.data.id, tag_name: tag, name: `Release ${tag}`, body, prerelease: false });
            } catch (err) {
              if (err.status === 404) {
                core.info(`No existing release for tag=${tag}, creating one`);
                release = await github.rest.repos.createRelease({ owner, repo, tag_name: tag, name: `Release ${tag}`, body, prerelease: false });
              } else {
                throw err;
              }
            }

            // Upload assets from downloaded-artifacts/target/*.jar
            const artifactsDir = path.join(process.cwd(), 'downloaded-artifacts', 'target');
            if (fs.existsSync(artifactsDir)) {
              const files = fs.readdirSync(artifactsDir).filter(f => f.endsWith('.jar'));
              for (const f of files) {
                const filePath = path.join(artifactsDir, f);
                const stats = fs.statSync(filePath);
                core.info(`Uploading asset ${f} (size=${stats.size}) to release ${release.data.id}`);
                const upload = await github.rest.repos.uploadReleaseAsset({
                  owner,
                  repo,
                  release_id: release.data.id,
                  name: f,
                  data: fs.readFileSync(filePath),
                  headers: { 'content-type': 'application/java-archive', 'content-length': stats.size }
                });
                core.info(`Uploaded asset: ${upload.data.browser_download_url}`);
              }
            } else {
              core.info(`No artifacts directory found at ${artifactsDir}`);
            }

            // Add labels to the merged PR (create labels if missing): released:<branch>, type:<fix|feature>, version:<version>
            if (pr_number) {
              const sanitized = (pr_head_ref || 'branch').replace(/\//g, '-');
              const releasedLabel = `released:${sanitized}`;
              const typeLabel = branch_type ? `type:${branch_type}` : null;
              const versionLabel = project_version ? `version:${project_version}` : null;
              const labelsToEnsure = [releasedLabel];
              if (typeLabel) labelsToEnsure.push(typeLabel);
              if (versionLabel) labelsToEnsure.push(versionLabel);

              for (const lbl of labelsToEnsure) {
                try {
                  await github.rest.issues.getLabel({ owner, repo, name: lbl });
                  core.info(`Label ${lbl} exists`);
                } catch (e) {
                  if (e.status === 404) {
                    core.info(`Creating label ${lbl}`);
                    await github.rest.issues.createLabel({ owner, repo, name: lbl, color: '0E8A16', description: 'Automatically created release label' });
                  } else {
                    throw e;
                  }
                }
              }
              core.info(`Adding labels ${labelsToEnsure.join(', ')} to PR #${pr_number}`);
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr_number, labels: labelsToEnsure });
            }
            return { release_id: release.data.id };
        env:
          RELEASE_TAG: ${{ steps.set_release_tag.outputs.release_tag }}
          IDENTIFY_RESULT: ${{ steps.identify_pr_and_artifact.outputs.result }}
          PROJECT_VERSION: ${{ steps.extract_metadata.outputs.project_version }}
          BRANCH_TYPE: ${{ steps.extract_metadata.outputs.branch_type }}
          STORY_ID: ${{ steps.extract_metadata.outputs.story_id }}
