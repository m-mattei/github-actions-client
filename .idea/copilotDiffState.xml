<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/prerelease.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/prerelease.yml" />
              <option name="originalContent" value="name: Create prerelease on push&#10;&#10;on:&#10;  workflow_run:&#10;    workflows:&#10;      - &quot;Java CI&quot;&#10;    types:&#10;      - completed&#10;&#10;permissions:&#10;  contents: write&#10;&#10;jobs:&#10;  create-prerelease:&#10;    # only run when the upstream workflow (Java CI) completed successfully&#10;    if: ${{ github.event.workflow_run.conclusion == 'success' }}&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;      - name: Checkout&#10;        uses: actions/checkout@v6&#10;        with:&#10;          # need full history to compute commit ranges and previous tags&#10;          fetch-depth: 0&#10;&#10;      # No build environment needed here — prerelease downloads artifacts from Java CI&#10;&#10;      - id: vars&#10;        name: Set short SHA and branch&#10;        run: |&#10;          # short SHA&#10;          echo &quot;short_sha=${GITHUB_SHA::7}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          # sanitized branch name (github.ref_name is available in newer runners, fall back to parsing GITHUB_REF)&#10;          if [ -n &quot;${GITHUB_REF_NAME}&quot; ]; then&#10;            branch=${GITHUB_REF_NAME}&#10;          else&#10;            branch=${GITHUB_REF#refs/heads/}&#10;          fi&#10;          # replace slashes with dashes for tag safety&#10;          branch_sanitized=${branch//\//-}&#10;          echo &quot;branch=${branch_sanitized}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - name: Download build artifacts from Java CI run&#10;        id: download_action&#10;        uses: actions/download-artifact@v6&#10;        with:&#10;          name: build-artifacts&#10;          path: downloaded-artifacts&#10;        continue-on-error: true&#10;&#10;      - id: check_download&#10;        name: Check downloaded artifacts&#10;        run: |&#10;          set -euo pipefail&#10;          if [ -n &quot;$(ls downloaded-artifacts/target/*.jar 2&gt;/dev/null)&quot; ]; then&#10;            echo &quot;downloaded=true&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          else&#10;            echo &quot;downloaded=false&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          fi&#10;&#10;      - id: fallback_identify&#10;        name: Fallback: locate artifact via GitHub API&#10;        if: ${{ steps.check_download.outputs.downloaded == 'false' }}&#10;        uses: actions/github-script@v5&#10;        with:&#10;          script: |&#10;            const owner = context.repo.owner;&#10;            const repo = context.repo.repo;&#10;            const run = context.payload.workflow_run;&#10;            const runId = run.id;&#10;            core.info(`Looking for artifacts on Java CI run id=${runId}`);&#10;            const arts = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id: runId });&#10;            if (!arts || !arts.data || !arts.data.artifacts || arts.data.artifacts.length === 0) {&#10;              throw new Error(`No artifacts found for Java CI run ${runId}`);&#10;            }&#10;            const artifact = arts.data.artifacts.find(a =&gt; a.name === 'build-artifacts') || arts.data.artifacts[0];&#10;            core.info(`Selected artifact ${artifact.name} (id=${artifact.id})`);&#10;            return { archive_url: artifact.archive_download_url };&#10;&#10;      - name: Fallback download and extract artifact&#10;        if: ${{ steps.check_download.outputs.downloaded == 'false' }}&#10;        run: |&#10;          set -euo pipefail&#10;          ARCHIVE_JSON=&quot;${{ steps.fallback_identify.outputs.result }}&quot;&#10;          echo &quot;$ARCHIVE_JSON&quot; &gt; /tmp/art.json&#10;          archive_url=$(jq -r '.archive_url' /tmp/art.json)&#10;          if [ -z &quot;$archive_url&quot; ] || [ &quot;$archive_url&quot; = &quot;null&quot; ]; then&#10;            echo &quot;No archive_url found in previous step output&quot; &gt;&amp;2&#10;            cat /tmp/art.json &gt;&amp;2 || true&#10;            exit 1&#10;          fi&#10;          mkdir -p downloaded-artifacts&#10;          echo &quot;Downloading artifact from: $archive_url&quot;&#10;          curl -L -H &quot;Authorization: Bearer $GITHUB_TOKEN&quot; -o /tmp/artifact.zip &quot;$archive_url&quot;&#10;          unzip -o /tmp/artifact.zip -d downloaded-artifacts&#10;        env:&#10;          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;&#10;      - name: List downloaded artifacts&#10;        run: |&#10;          echo &quot;Downloaded files:&quot; &amp;&amp; ls -R downloaded-artifacts || true&#10;&#10;      - name: Check for built JAR(s)&#10;        run: |&#10;          set -euo pipefail&#10;          if [ -z &quot;$(ls downloaded-artifacts/target/*.jar 2&gt;/dev/null)&quot; ]; then&#10;            echo &quot;Error: No JAR files found in downloaded-artifacts/target/*.jar&quot; &gt;&amp;2&#10;            echo &quot;Make sure the 'Java CI' workflow uploaded artifacts named 'build-artifacts' that include target/*.jar&quot; &gt;&amp;2&#10;            exit 1&#10;          fi&#10;          echo &quot;Found JAR(s):&quot; &amp;&amp; ls downloaded-artifacts/target/*.jar&#10;&#10;      - id: tests&#10;        name: Summarize test results&#10;        run: |&#10;          set -euo pipefail&#10;          summary=&quot;&quot;&#10;          reports_dir=downloaded-artifacts/target/surefire-reports&#10;          if [ ! -d &quot;$reports_dir&quot; ] || [ -z &quot;$(ls &quot;$reports_dir&quot;/TEST-*.xml 2&gt;/dev/null)&quot; ]; then&#10;            summary=&quot;No test reports found.&quot;&#10;          else&#10;            total=0; failures=0; errors=0; skipped=0&#10;            for f in &quot;$reports_dir&quot;/TEST-*.xml; do&#10;              t=$(sed -n 's/.*tests=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              fa=$(sed -n 's/.*failures=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              er=$(sed -n 's/.*errors=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              sk=$(sed -n 's/.*skipped=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              total=$((total + t))&#10;              failures=$((failures + fa))&#10;              errors=$((errors + er))&#10;              skipped=$((skipped + sk))&#10;            done&#10;            summary=&quot;Tests: ${total}, Failures: ${failures}, Errors: ${errors}, Skipped: ${skipped}&quot;&#10;          fi&#10;          echo &quot;test_summary=${summary}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - id: notes&#10;        name: Generate release notes from commits and tests&#10;        run: |&#10;          set -euo pipefail&#10;          test_summary=&quot;${{ steps.tests.outputs.test_summary }}&quot;&#10;          # If the push event doesn't have a valid before ref (initial commit), fallback to last 50 commits&#10;          if [ &quot;${GITHUB_EVENT_BEFORE}&quot; = &quot;0000000000000000000000000000000000000000&quot; ] || ! git rev-parse --verify &quot;${GITHUB_EVENT_BEFORE}&quot; &gt;/dev/null 2&gt;&amp;1; then&#10;            commits=$(git log --pretty=format:'- %s (%h) by %an' -n 50)&#10;          else&#10;            commits=$(git log --pretty=format:'- %s (%h) by %an' ${GITHUB_EVENT_BEFORE}..${GITHUB_SHA})&#10;          fi&#10;          if [ -z &quot;$(echo &quot;$commits&quot; | tr -d '\n' | tr -d ' ')&quot; ]; then&#10;            commits_msg=&quot;No commit messages available for this release.&quot;&#10;          else&#10;            commits_msg=&quot;$commits&quot;&#10;          fi&#10;          full_notes=&quot;Test summary: ${test_summary}\n\nCommits included in this pre-release:\n${commits_msg}&quot;&#10;          echo &quot;notes&lt;&lt;EOF&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          echo &quot;$full_notes&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          echo &quot;EOF&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - name: Create pre-release&#10;        uses: ncipollo/release-action@v1&#10;        with:&#10;          # use branch + short sha + run number so tags are readable and unique&#10;          tag: prerelease-${{ steps.vars.outputs.branch }}-${{ steps.vars.outputs.short_sha }}-${{ github.run_number }}&#10;          name: Pre-release from ${{ steps.vars.outputs.branch }} (run ${{ github.run_number }})&#10;          body: ${{ steps.notes.outputs.notes }}&#10;          prerelease: true&#10;          # attach the built JAR(s)&#10;          files: downloaded-artifacts/target/*.jar&#10;        env:&#10;          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;" />
              <option name="updatedContent" value="name: Create prerelease on push&#10;&#10;on:&#10;  workflow_run:&#10;    workflows:&#10;      - &quot;Java CI&quot;&#10;    types:&#10;      - completed&#10;&#10;permissions:&#10;  contents: write&#10;&#10;jobs:&#10;  create-prerelease:&#10;    # only run when the upstream workflow (Java CI) completed successfully&#10;    if: ${{ github.event.workflow_run.conclusion == 'success' }}&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;      - name: Checkout&#10;        uses: actions/checkout@v6&#10;        with:&#10;          # need full history to compute commit ranges and previous tags&#10;          fetch-depth: 0&#10;&#10;      # No build environment needed here — prerelease downloads artifacts from Java CI&#10;&#10;      - id: vars&#10;        name: Set short SHA and branch&#10;        run: |&#10;          # short SHA&#10;          echo &quot;short_sha=${GITHUB_SHA::7}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          # sanitized branch name (github.ref_name is available in newer runners, fall back to parsing GITHUB_REF)&#10;          if [ -n &quot;${GITHUB_REF_NAME}&quot; ]; then&#10;            branch=${GITHUB_REF_NAME}&#10;          else&#10;            branch=${GITHUB_REF#refs/heads/}&#10;          fi&#10;          # replace slashes with dashes for tag safety&#10;          branch_sanitized=${branch//\//-}&#10;          echo &quot;branch=${branch_sanitized}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - name: Download build artifacts from Java CI run&#10;        id: download_action&#10;        uses: actions/download-artifact@v6&#10;        with:&#10;          name: build-artifacts&#10;          path: downloaded-artifacts&#10;        continue-on-error: true&#10;&#10;      - name: Set branch-based release tag&#10;        id: set_release_tag&#10;        run: |&#10;          set -euo pipefail&#10;          # Get head branch and SHA from workflow_run payload&#10;          head_branch=&quot;${{ github.event.workflow_run.head_branch }}&quot;&#10;          head_sha=&quot;${{ github.event.workflow_run.head_sha }}&quot;&#10;          if [ -z &quot;$head_branch&quot; ]; then&#10;            echo &quot;Error: unable to determine head branch from workflow_run&quot; &gt;&amp;2&#10;            exit 1&#10;          fi&#10;          sanitized=${head_branch//\//-}&#10;          tag=&quot;branch-${sanitized}&quot;&#10;          echo &quot;release_tag=${tag}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          echo &quot;release_commit=${head_sha}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - name: Create/force-update git tag for branch&#10;        if: ${{ always() &amp;&amp; steps.set_release_tag.outputs.release_tag }}&#10;        run: |&#10;          set -euo pipefail&#10;          git config user.name &quot;${GITHUB_ACTOR}&quot;&#10;          git config user.email &quot;${GITHUB_ACTOR}@users.noreply.github.com&quot;&#10;          tag=&quot;${{ steps.set_release_tag.outputs.release_tag }}&quot;&#10;          commit=&quot;${{ steps.set_release_tag.outputs.release_commit }}&quot;&#10;          git tag -f &quot;$tag&quot; &quot;$commit&quot;&#10;          git push -f origin &quot;refs/tags/$tag&quot;&#10;        env:&#10;          GITHUB_ACTOR: ${{ github.actor }}&#10;&#10;      - name: Delete existing release for branch tag (if any)&#10;        if: ${{ always() &amp;&amp; steps.set_release_tag.outputs.release_tag }}&#10;        uses: actions/github-script@v8&#10;        with:&#10;          script: |&#10;            const owner = context.repo.owner;&#10;            const repo = context.repo.repo;&#10;            const tag = process.env.RELEASE_TAG;&#10;            try {&#10;              const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });&#10;              core.info(`Found existing release id=${rel.data.id} for tag=${tag}, deleting it`);&#10;              await github.rest.repos.deleteRelease({ owner, repo, release_id: rel.data.id });&#10;            } catch (err) {&#10;              if (err.status === 404) {&#10;                core.info(`No existing release for tag=${tag}`);&#10;              } else {&#10;                throw err;&#10;              }&#10;            }&#10;        env:&#10;          RELEASE_TAG: ${{ steps.set_release_tag.outputs.release_tag }}&#10;&#10;      - id: check_download&#10;        name: Check downloaded artifacts&#10;        run: |&#10;          set -euo pipefail&#10;          if [ -n &quot;$(ls downloaded-artifacts/target/*.jar 2&gt;/dev/null)&quot; ]; then&#10;            echo &quot;downloaded=true&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          else&#10;            echo &quot;downloaded=false&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          fi&#10;&#10;      - id: fallback_identify&#10;        name: Fallback: locate artifact via GitHub API&#10;        if: ${{ steps.check_download.outputs.downloaded == 'false' }}&#10;        uses: actions/github-script@v8&#10;        with:&#10;          script: |&#10;            const owner = context.repo.owner;&#10;            const repo = context.repo.repo;&#10;            const run = context.payload.workflow_run;&#10;            const runId = run.id;&#10;            core.info(`Looking for artifacts on Java CI run id=${runId}`);&#10;            const arts = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id: runId });&#10;            if (!arts || !arts.data || !arts.data.artifacts || arts.data.artifacts.length === 0) {&#10;              throw new Error(`No artifacts found for Java CI run ${runId}`);&#10;            }&#10;            const artifact = arts.data.artifacts.find(a =&gt; a.name === 'build-artifacts') || arts.data.artifacts[0];&#10;            core.info(`Selected artifact ${artifact.name} (id=${artifact.id})`);&#10;            return { archive_url: artifact.archive_download_url };&#10;&#10;      - name: Fallback download and extract artifact&#10;        if: ${{ steps.check_download.outputs.downloaded == 'false' }}&#10;        run: |&#10;          set -euo pipefail&#10;          ARCHIVE_JSON=&quot;${{ steps.fallback_identify.outputs.result }}&quot;&#10;          echo &quot;$ARCHIVE_JSON&quot; &gt; /tmp/art.json&#10;          archive_url=$(jq -r '.archive_url' /tmp/art.json)&#10;          if [ -z &quot;$archive_url&quot; ] || [ &quot;$archive_url&quot; = &quot;null&quot; ]; then&#10;            echo &quot;No archive_url found in previous step output&quot; &gt;&amp;2&#10;            cat /tmp/art.json &gt;&amp;2 || true&#10;            exit 1&#10;          fi&#10;          mkdir -p downloaded-artifacts&#10;          echo &quot;Downloading artifact from: $archive_url&quot;&#10;          curl -L -H &quot;Authorization: Bearer $GITHUB_TOKEN&quot; -o /tmp/artifact.zip &quot;$archive_url&quot;&#10;          unzip -o /tmp/artifact.zip -d downloaded-artifacts&#10;        env:&#10;          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;&#10;      - name: List downloaded artifacts&#10;        run: |&#10;          echo &quot;Downloaded files:&quot; &amp;&amp; ls -R downloaded-artifacts || true&#10;&#10;      - name: Check for built JAR(s)&#10;        run: |&#10;          set -euo pipefail&#10;          if [ -z &quot;$(ls downloaded-artifacts/target/*.jar 2&gt;/dev/null)&quot; ]; then&#10;            echo &quot;Error: No JAR files found in downloaded-artifacts/target/*.jar&quot; &gt;&amp;2&#10;            echo &quot;Make sure the 'Java CI' workflow uploaded artifacts named 'build-artifacts' that include target/*.jar&quot; &gt;&amp;2&#10;            exit 1&#10;          fi&#10;          echo &quot;Found JAR(s):&quot; &amp;&amp; ls downloaded-artifacts/target/*.jar&#10;&#10;      - id: tests&#10;        name: Summarize test results&#10;        run: |&#10;          set -euo pipefail&#10;          summary=&quot;&quot;&#10;          reports_dir=downloaded-artifacts/target/surefire-reports&#10;          if [ ! -d &quot;$reports_dir&quot; ] || [ -z &quot;$(ls &quot;$reports_dir&quot;/TEST-*.xml 2&gt;/dev/null)&quot; ]; then&#10;            summary=&quot;No test reports found.&quot;&#10;          else&#10;            total=0; failures=0; errors=0; skipped=0&#10;            for f in &quot;$reports_dir&quot;/TEST-*.xml; do&#10;              t=$(sed -n 's/.*tests=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              fa=$(sed -n 's/.*failures=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              er=$(sed -n 's/.*errors=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              sk=$(sed -n 's/.*skipped=&quot;\([0-9]*\)&quot;.*/\1/p' &quot;$f&quot; | head -n1 || echo 0)&#10;              total=$((total + t))&#10;              failures=$((failures + fa))&#10;              errors=$((errors + er))&#10;              skipped=$((skipped + sk))&#10;            done&#10;            summary=&quot;Tests: ${total}, Failures: ${failures}, Errors: ${errors}, Skipped: ${skipped}&quot;&#10;          fi&#10;          echo &quot;test_summary=${summary}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - id: notes&#10;        name: Generate release notes from commits and tests&#10;        run: |&#10;          set -euo pipefail&#10;          test_summary=&quot;${{ steps.tests.outputs.test_summary }}&quot;&#10;          # If the push event doesn't have a valid before ref (initial commit), fallback to last 50 commits&#10;          if [ &quot;${GITHUB_EVENT_BEFORE}&quot; = &quot;0000000000000000000000000000000000000000&quot; ] || ! git rev-parse --verify &quot;${GITHUB_EVENT_BEFORE}&quot; &gt;/dev/null 2&gt;&amp;1; then&#10;            commits=$(git log --pretty=format:'- %s (%h) by %an' -n 50)&#10;          else&#10;            commits=$(git log --pretty=format:'- %s (%h) by %an' ${GITHUB_EVENT_BEFORE}..${GITHUB_SHA})&#10;          fi&#10;          if [ -z &quot;$(echo &quot;$commits&quot; | tr -d '\n' | tr -d ' ')&quot; ]; then&#10;            commits_msg=&quot;No commit messages available for this release.&quot;&#10;          else&#10;            commits_msg=&quot;$commits&quot;&#10;          fi&#10;          full_notes=&quot;Test summary: ${test_summary}\n\nCommits included in this pre-release:\n${commits_msg}&quot;&#10;          echo &quot;notes&lt;&lt;EOF&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          echo &quot;$full_notes&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;          echo &quot;EOF&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;&#10;&#10;      - name: Create pre-release&#10;        uses: actions/github-script@v8&#10;        with:&#10;          script: |&#10;            const fs = require('fs');&#10;            const path = require('path');&#10;            const owner = context.repo.owner;&#10;            const repo = context.repo.repo;&#10;            const tag = process.env.RELEASE_TAG;&#10;            const body = process.env.RELEASE_NOTES || '';&#10;            const isDraft = false;&#10;            const preRelease = true;&#10;            let id = 0;&#10;            try {&#10;              const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });&#10;              id = rel.data.id;&#10;              core.info(`Found existing release id=${id} for tag=${tag}`);&#10;              // Update release notes if they differ from the current notes&#10;              if (rel.data.body !== body) {&#10;                core.info(`Updating release notes for id=${id}`);&#10;                await github.rest.repos.updateRelease({&#10;                  owner,&#10;                  repo,&#10;                  release_id: id,&#10;                  tag_name: tag,&#10;                  name: tag,&#10;                  body,&#10;                  draft: isDraft,&#10;                  prerelease: preRelease&#10;                });&#10;              } else {&#10;                core.info(`Release notes are identical, skipping update for id=${id}`);&#10;              }&#10;            } catch (err) {&#10;              if (err.status === 404) {&#10;                core.info(`Release not found, creating new release for tag=${tag}`);&#10;                const rel = await github.rest.repos.createRelease({&#10;                  owner,&#10;                  repo,&#10;                  tag_name: tag,&#10;                  name: tag,&#10;                  body,&#10;                  draft: isDraft,&#10;                  prerelease: preRelease&#10;                });&#10;                id = rel.data.id;&#10;              } else {&#10;                throw err;&#10;              }&#10;            }&#10;            // Upload JAR files to the release&#10;            const jarFiles = fs.readdirSync('downloaded-artifacts/target').filter(f =&gt; f.endsWith('.jar'));&#10;            for (const file of jarFiles) {&#10;              const filePath = path.join('downloaded-artifacts/target', file);&#10;              core.info(`Uploading JAR file to release: ${file}`);&#10;              await github.rest.repos.uploadReleaseAsset({&#10;                owner,&#10;                repo,&#10;                release_id: id,&#10;                asset_name: file,&#10;                asset_data: fs.readFileSync(filePath),&#10;                headers: {&#10;                  'Content-Type': 'application/java-archive'&#10;                }&#10;              });&#10;            }&#10;            return { release_id: id };&#10;        env:&#10;          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;          RELEASE_TAG: ${{ steps.set_release_tag.outputs.release_tag }}&#10;          RELEASE_NOTES: ${{ steps.notes.outputs.notes }}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>